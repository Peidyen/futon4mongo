#!/usr/bin/env ruby 

# Licensed under the Apache License, Version 2.0 (the "License"); you may not use
# this file except in compliance with the License. You may obtain a copy of the
# License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.



require "rubygems"
require "sinatra"
require "net/http"
require "yajl"
require 'yajl/json_gem'
require "pp"
require "mongo"

set :public, File.dirname(__FILE__)

MONGO_HOST = "127.0.0.1"
MONGO_PORT = 27017
MONGO_WEB_PORT = 28017

get "/q/:db/:collection" do
  content_type "application/json"
  proxy MONGO_HOST, MONGO_WEB_PORT, params
end

get "/" do
  respond({
    "couchdb" => "Welcome",
    "version" => "mongodb-1.0"
  })
end

get "/_config/*" do
  if params["splat"][0] == "query_servers/"
    '{"javascript":"/usr/local/bin/couchjs /usr/local/share/couchdb/server/main.js"}'
  end
end

get "/_all_dbs" do
  all_dbs = conn.database_names.map do |db_name| 
    conn.db(db_name).collection_names.map do |col_name| 
      [db_name, col_name].join("/") unless col_name.split(".")[0] == "system"
    end
  end.flatten.compact
  respond all_dbs
end

get "/_:command/*" do
end



get "/:database/:collection/" do
  collection = conn.db(params["database"]).collection(params["collection"])
  respond({
    "db_name" => [params["database"], params["collection"]].join("/"),
    "doc_count" => collection.count,
    "disk_size" => 123
  })
end

get "/:database/:collection/_all_docs" do
  col = conn.db(params["database"]).collection(params["collection"])
  options = {}
  options[:limit] = params["limit"].nil? ? 10 : params["limit"].to_i
  options[:sort] = { "_id" => (params["descending"] == "true" ? -1 : 1) }
  
  query = {}
  
  if (params["startkey"] || params["endkey"])
    query["_id"] ||= {}
    query["_id"]["$gte"] = params["startkey"].gsub('"', "") if params["startkey"]
    query["_id"]["$lte"] = params["endkey"].gsub('"', "") if params["endkey"]
  end
  
  
  puts "\n\n\n==============  QUERY HERE ====================="
  pp query
  
  res = col.find(query, options)
  rows = res.to_a.map do |doc|
    
    doc["_id"] = doc["_id"].to_s
    
    d = { 
      "id" => doc["_id"],
      "key" => doc["_id"],
      "value" => doc.keys
    }
    d["doc"] = doc if params["include_docs"] == "true" 
    
    d
  end
  
  respond({
    "total_rows" => res.count,
    "offset" => params["offset"] || 0,
    "rows" => rows
   })
end

get "/:database/:collection/_design/:design_doc/_view/:view_name" do 
  col = conn.db(params["database"]).collection(params["collection"])
  design_doc = col.find_one({ "_id" => "_design/#{params["design_doc"]}" }, :limit => 1)
  if design_doc && design_doc["views"]
    if design_doc["views"][params["view_name"]]
      map = design_doc["views"][params["view_name"]]["map"]
    end
  end
  
  opts = {}
  opts[:limit] = params["limit"].nil? ? 11 : params["limit"].to_i
  
  res = col.find(map, opts)
  
  rows = res.to_a.map do |doc|
    
    doc["_id"] = doc["_id"].to_s
    
    d = { 
      "id" => doc["_id"],
      "key" => doc["_id"],
      "value" => doc.keys
    }
    d
  end
  
  
  respond({
    "total_rows" => res.count,
    "offset" => params["offset"] || 0,
    "rows" => rows
   })
  
end



get "/:database/:collection/*" do
  col = conn.db(params["database"]).collection(params["collection"])  
  id = params["splat"].join("/")
  doc = find_doc(col, id)
  
  if doc.nil?
    error_not_found
  else
    doc["_id"] = doc["_id"].to_s
    respond(doc)
  end
end

put "/:database/:collection/*" do
  id = params["splat"].join("/")
  col = conn.db(params["database"]).collection(params["collection"])
  doc = Yajl::Parser.new.parse(request.body)
  doc.delete("_id")
  
  original_doc = find_doc(col, id)
  
  puts "\n\n\n\n\n\n\n====== Found original doc... #{original_doc["_id"].class} : #{original_doc["_id"]}"
  pp original_doc
  
  id = original_doc["_id"] rescue nil

  if id.nil?
    error_not_found
  else
    res = col.update({ "_id" => id }, { "$set" => doc }, :upsert => true)
    
    puts "\n\n\n========== Saving doc #{id.class} : #{id}"
    pp doc
    
    content_type "application/json"
    headers "Connection" => "close"
    status 201
    {"ok" => true, "id" => id.to_s, "rev" => "123"}.to_json
  end
end

delete "/:database/:collection/*" do
  id = params["splat"].join("/")
  col = conn.db(params["database"]).collection(params["collection"])
  
  original_doc = find_doc(col, id)
  id = original_doc["_id"] rescue nil

  if id.nil?
    error_not_found
  else
    col.remove({ "_id" => id })
    content_type "application/json"
    headers "Connection" => "close"
    status 200
    {"ok" => true, "rev" => "123"}.to_json
  end
  
  
end

private

def error_not_found
  status 404
  '{"error":"not_found","reason":"missing"}'
end

def find_doc(col, id)
  doc = col.find_one({ "_id" => id.to_s })
  doc ||= col.find_one({ "_id" => id.to_i })
  if doc.nil?
    begin
      id = Mongo::ObjectID.from_string(id.to_s)
      doc = col.find_one({ "_id" => id })
    rescue
      nil
    end
  end
  doc
end

def conn
  @conn ||= Mongo::Connection.new(MONGO_HOST, MONGO_PORT)
end

def respond(data)
  content_type "application/json"
  data.is_a?(String) ? data : data.to_json
end

def proxy host, port, params
  get_params = params
  db = get_params.delete("db")
  collection = get_params.delete("collection")
  
  get_params["limit"] = get_params["limit"].nil? ? -10 : get_params["limit"].to_i.abs * -1
  url = "/#{db}/#{collection}/?#{(get_params.map { |k, v|  "#{k}=#{v}" }).join("&")}"
  http = Net::HTTP.new(host, port)
  response, data = http.get(url) rescue ["", ""]
  data
end
