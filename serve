#!/usr/bin/env ruby 

# Licensed under the Apache License, Version 2.0 (the "License"); you may not use
# this file except in compliance with the License. You may obtain a copy of the
# License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.

require "rubygems"
require "sinatra"
require "net/http"
require "yajl"
require 'yajl/json_gem'
require "pp"
require "mongo"

module Mongo
  class ObjectID
    def to_json
      return self.to_s
    end
  end
end

set :public, File.dirname(__FILE__)

before do
  content_type "application/json"
end

get "/" do
  { "couchdb" => "Welcome", "version" => "mongodb-1.0" }.to_json
end

get "/_config/*" do
  if params["splat"][0] == "query_servers/"
    # Dummy response for futon...
    '{"javascript":"/usr/local/bin/couchjs /usr/local/share/couchdb/server/main.js"}'
  end
end

get "/_all_dbs" do
  all_dbs.map { |n,c| c.map { |cn| [n,cn].join("/") } }.flatten.compact.to_json
end


get "/:database/:collection/" do
  {
    "db_name" => [params["database"], params["collection"]].join("/"),
    "doc_count" => col.count,
    "disk_size" => 123
  }.to_json
end

get "/:database/:collection/_all_docs" do
  options = {}
  options[:limit] = params["limit"].nil? ? 10 : params["limit"].to_i
  options[:sort] = { "_id" => (params["descending"] == "true" ? -1 : 1) }
  
  query = {}
  
  if (params["startkey"] || params["endkey"])
    query["_id"] ||= {}
    query["_id"]["$gte"] = params["startkey"].gsub('"', "") if params["startkey"]
    query["_id"]["$lte"] = params["endkey"].gsub('"', "") if params["endkey"]
  end
    
  res = col.find(query, options)
  
  rows = res.to_a.map do |doc|
    doc["_id"] = doc["_id"].to_s
    d = { "id" => doc["_id"], "key" => doc["_id"], "value" => doc.keys }
    d["doc"] = doc if params["include_docs"] == "true"
    d
  end
  
  {
    "total_rows" => res.count,
    "offset" => params["offset"] || 0,
    "rows" => rows
   }.to_json
   
end

get "/:database/:collection/_design/:design_doc/_view/:view_name" do 
  col = conn.db(params["database"]).collection(params["collection"])
  design_doc = col.find_one({ "_id" => "_design/#{params["design_doc"]}" }, :limit => 1)
  if design_doc && design_doc["views"]
    if design_doc["views"][params["view_name"]]
      map = design_doc["views"][params["view_name"]]["map"]
    end
  end
  
  opts = {}
  opts[:limit] = params["limit"].nil? ? 11 : params["limit"].to_i
  
  res = col.find(map, opts)
  
  rows = res.to_a.map do |doc|
    doc["_id"] = doc["_id"].to_s
    
    { 
      "id" => doc["_id"],
      "key" => doc["_id"],
      "value" => doc.keys
    }
  end
  
  {
    "total_rows" => res.count,
    "offset" => params["offset"] || 0,
    "rows" => rows
   }.to_json
  
end



get "/:database/:collection/*" do
  col = conn.db(params["database"]).collection(params["collection"])  
  id = params["splat"].join("/")
  doc = find_doc(col, id)
  
  if doc.nil?
    error_not_found
  else
    doc["_id"] = doc["_id"].to_s
    doc.to_json
  end
end

put "/:database/:collection/*" do
  id = params["splat"].join("/")
  col = conn.db(params["database"]).collection(params["collection"])
  doc = Yajl::Parser.new.parse(request.body)
  doc.delete("_id")
  
  original_doc = find_doc(col, id)
  id = original_doc["_id"] rescue nil

  if id.nil?
    error_not_found
  else
    doc["_id"] = id
    res = col.update({ "_id" => id }, doc)
    
    content_type "application/json"
    headers "Connection" => "close"
    status 201
    {"ok" => true, "id" => id.to_s, "rev" => "123"}.to_json
  end
end

delete "/:database/:collection/*" do
  id = params["splat"].join("/")
  col = conn.db(params["database"]).collection(params["collection"])
  
  original_doc = find_doc(col, id)
  id = original_doc["_id"] rescue nil

  if id.nil?
    error_not_found
  else
    col.remove({ "_id" => id })
    content_type "application/json"
    headers "Connection" => "close"
    status 200
    {"ok" => true, "rev" => "123"}.to_json
  end
end

private

def error_not_found
  status 404
  '{"error":"not_found","reason":"missing"}'
end

def db d=nil 
  conn.db(d || params[:database])
end

def col c=nil, d=nil
  db(d).collection(c || params[:collection])
end

def docs f
  
end

def all_dbs
  conn.database_names.inject({}) { |dbs, d| dbs.merge({ d => conn.db(d).collection_names }) }
end

def find_doc(col, id)
  ids = [id.to_s, id.to_i]
  begin
    ids << Mongo::ObjectID.from_string(id.to_s)
  rescue
    nil
  end
  col.find_one({ "_id" => { "$in" => ids } })
end

def conn
  host = ARGV[0] || "127.0.0.1"
  port = ARGV[1] || 27017
  @conn ||= Mongo::Connection.new(host, port)
end

