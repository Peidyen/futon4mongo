#!/usr/bin/env ruby 

# Licensed under the Apache License, Version 2.0 (the "License"); you may not use
# this file except in compliance with the License. You may obtain a copy of the
# License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.

require "rubygems"
require "sinatra"
require "net/http"
require "yajl"
require 'yajl/json_gem'
require "pp"
require "mongo"
require "uri"
require "cgi"


module Mongo
  class ObjectID
    def to_json
      return self.to_s
    end
  end
end

set :public, File.dirname(__FILE__)

before do
  content_type "application/json"
end

get "/" do
  { "mongodb" => "Welcome", "version" => "mongodb-1.0" }.to_json
end

get "/_config/*" do
  if params["splat"][0] == "query_servers/"
    # Dummy response for futon...
    '{"javascript":"/usr/local/bin/couchjs /usr/local/share/couchdb/server/main.js"}'
  end
end

# DB operations

get "/_all_dbs" do
  all_dbs.map { |n,c| c.map { |cn| [n,cn].join("/") } }.flatten.compact.to_json
end

get "/_uuids" do 
  referrer = URI.parse(request.env["HTTP_REFERER"])
  db_name, col_name = CGI::unescape(referrer.query).split("/", 2)

  if (db_name && col_name)
    { "uuids" => [col(col_name, db_name).insert({}).to_s] }.to_json
  end
end

get "/_active_tasks" do
  [].to_json
end

put "/:database/:collection/" do
  db.create_collection(params[:collection])
  status 201
  { "ok" => "true" }.to_json
end

delete "/:database/:collection/" do
  db.drop_collection(params[:collection])
  status 200
  { "ok" => "true" }.to_json
end

get "/:database/:collection/" do
  {
    "db_name" => [params["database"], params["collection"]].join("/"),
    "doc_count" => col.count,
    "disk_size" => 123
  }.to_json
end

get "/:database/:collection/_all_docs" do
  options = {}
  options[:limit] = params["limit"].nil? ? 10 : params["limit"].to_i
  options[:sort] = { "_id" => (params["descending"] == "true" ? -1 : 1) }
  options[:offset] = params["skip"].to_i unless params["skip"].nil?
  
  query = {}
  query_obj = {}
  
  if (params["startkey_docid"])
    begin
      query_obj["_id"] = { "$gte" => Mongo::ObjectID.from_string(params["startkey_docid"]) }
    rescue
      
      if params["startkey_docid"] =~ /^[0-9]+$/
        s = params["startkey_docid"].to_i 
      end
      
      query["_id"] = { "$gte" => s }
    end
  
  elsif (params["startkey"] || params["endkey"])
    s = params["startkey"].gsub('"', "") if params["startkey"]
    e = params["endkey"].gsub('"', "") if params["endkey"]
    
    if params["startkey"] && params["endkey"] && params["limit"] == "10" && params["endkey"].gsub('"', "")[-1] == 122
      start_key = Mongo::ObjectID.from_string(s.ljust(24, "0")) rescue s
      end_key = Mongo::ObjectID.from_string(e.gsub("z", "f").ljust(24, "f")) rescue e
      query_obj["_id"] ||= {}
      query_obj["_id"]["$gte"] = start_key if start_key
      query_obj["_id"]["$lte"] = end_key if end_key
    end
    
    s = s.to_i if s =~ /^[0-9]+$/
    e = e.to_i if e =~ /^[0-9]+$/
    
    query["_id"] ||= {}
    query["_id"]["$gte"] = s if s
    query["_id"]["$lte"] = e if e
  end
    
    
    
  if query_obj["_id"]
    res = col.find(query_obj, options)
  end
  
  if res.nil? || res.count == 0
    res = col.find(query, options) 
  end
  
  results =  res.to_a

  rows = results.map do |doc|
    doc["_id"] = doc["_id"].to_s
    d = { "id" => doc["_id"], "key" => doc["_id"], "value" => doc.keys }
    d["doc"] = doc if params["include_docs"] == "true"
    d
  end
  
  {
    "total_rows" => res.count,
    "offset" => params["offset"] || 0,
    "rows" => rows
   }.to_json
   
end

get "/:database/:collection/_design/:design_doc/_view/:view_name" do 
  col = conn.db(params["database"]).collection(params["collection"])
  design_doc = col.find_one({ "_id" => "_design/#{params["design_doc"]}" }, :limit => 1)
  if design_doc && design_doc["views"]
    if design_doc["views"][params["view_name"]]
      map = design_doc["views"][params["view_name"]]["map"]
    end
  end
  
  opts = {}
  opts[:limit] = params["limit"].nil? ? 11 : params["limit"].to_i
  
  res = col.find(map, opts)
  
  rows = res.to_a.map do |doc|
    doc["_id"] = doc["_id"].to_s
    
    { 
      "id" => doc["_id"],
      "key" => doc["_id"],
      "value" => doc.keys
    }
  end
  
  {
    "total_rows" => res.count,
    "offset" => params["offset"] || 0,
    "rows" => rows
   }.to_json
  
end



get "/:database/:collection/*" do
  col = conn.db(params["database"]).collection(params["collection"])  
  id = params["splat"].join("/")
  doc = find_doc(col, id)
  
  if doc.nil?
    error_not_found
  else
    doc["_id"] = doc["_id"].to_s
    doc.to_json
  end
end

put "/:database/:collection/*" do
  id = params["splat"].join("/")
  col = conn.db(params["database"]).collection(params["collection"])
  doc = Yajl::Parser.new.parse(request.body)
  doc.delete("_id")
  
  original_doc = find_doc(col, id)
  id = original_doc["_id"] rescue nil

  if id.nil?
    error_not_found
  else
    doc["_id"] = id
    res = col.update({ "_id" => id }, doc)
    
    content_type "application/json"
    headers "Connection" => "close"
    status 201
    {"ok" => true, "id" => id.to_s, "rev" => "123"}.to_json
  end
end

delete "/:database/:collection/*" do
  id = params["splat"].join("/")
  col = conn.db(params["database"]).collection(params["collection"])
  
  original_doc = find_doc(col, id)
  id = original_doc["_id"] rescue nil

  if id.nil?
    error_not_found
  else
    col.remove({ "_id" => id })
    content_type "application/json"
    headers "Connection" => "close"
    status 200
    {"ok" => true, "rev" => "123"}.to_json
  end
end

private

def error_not_found
  status 404
  '{"error":"not_found","reason":"missing"}'
end

def db d=nil 
  conn.db(d || params[:database])
end

def col c=nil, d=nil
  db(d).collection(c || params[:collection])
end

def docs f
  
end

def all_dbs include_system=false
  conn.database_names.inject({}) do |dbs, d|
    dbs.merge({ d => conn.db(d).collection_names.map { |c| c unless (c.split(".")[0] == "system" && !include_system) }.compact })
  end
end

def find_doc(col, id)
  ids = [id.to_s, id.to_i]
  begin
    ids << Mongo::ObjectID.from_string(id.to_s)
  rescue
    nil
  end
  col.find_one({ "_id" => { "$in" => ids } })
end

def conn
  host = ARGV[0] || "127.0.0.1"
  port = ARGV[1] || 27017
  @conn ||= Mongo::Connection.new(host, port)
end

